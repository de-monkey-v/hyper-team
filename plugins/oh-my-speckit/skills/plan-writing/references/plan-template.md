# Plan Template

구현 계획 문서 작성 시 사용하는 전체 템플릿.

## 템플릿

```markdown
# Plan: [Feature Name]

## 개요
[한 문단 요약 - 무엇을 어떻게 구현할지]

## 코드베이스 분석 결과

### 프로젝트 구조
- **아키텍처**: [확인된 패턴]
- **주요 디렉토리**: [관련 디렉토리 목록]

### 참고할 기존 코드
- `[파일 경로]` - [참고 이유]

### 재사용 가능한 컴포넌트
- `[컴포넌트]` - [재사용 방법]

## 재사용 분석 (필수)

### 기존 코드 활용 계획
| 기존 코드 | 용도 | 활용 방법 |
|----------|------|----------|
| `src/utils/...` | [용도] | import |
| `src/components/...` | [용도] | 확장/래핑 |

### 영향 분석 (기존 코드 수정 시)
| 수정 파일 | 변경 내용 | 영향받는 파일 | 영향도 |
|----------|----------|-------------|-------|
| `src/...` | [변경] | [파일 목록] | 낮음/중간/높음 |

### 새로 작성이 필요한 코드
| 파일 | 이유 | 재사용 불가 근거 |
|------|------|----------------|
| `src/...` | [이유] | 유사 기능 없음 |

## FR 매핑

| FR | AC (합격 기준) | Phase | 대상 파일 | 검증 방법 |
|----|---------------|-------|----------|----------|
| FR1 | [spec.md에서 가져온 AC] | Phase 1 | `src/...` | 단위 테스트 / 타입 체크 / 수동 확인 |
| FR2 | [AC] | Phase 2 | `src/...` | 통합 테스트 |
| FR3 | [AC] | Phase 2-3 | `src/...` | E2E 테스트 |

## 변경 파일

### 생성
| 파일 | 설명 |
|------|------|
| `src/...` | ... |

### 수정
| 파일 | 변경 내용 |
|------|----------|
| `src/...` | ... |

### 삭제 (해당시)
| 파일 | 삭제 이유 |
|------|----------|
| `src/...` | ... |

## Breaking Change (해당시)

### V2로 생성할 API
| 기존 | 신규 (V2) | 변경 이유 |
|------|----------|----------|
| `GET /api/users` | `GET /api/v2/users` | 응답 구조 변경 |

### Deprecated 처리할 항목
- `UserDto` → `UserDtoV2`로 대체
- `getUsers()` → `getUsersV2()`로 대체

### 마이그레이션 가이드
- 변경 사항 요약
- Before/After 예시

## E2E 테스트 시나리오

### 핵심 시나리오
| 시나리오 | 사전조건 | 액션 | 예상 결과 |
|---------|---------|------|----------|
| [시나리오명] | [필요한 상태] | [사용자 행동] | [기대 결과] |

### 엣지 케이스
| 시나리오 | 조건 | 예상 결과 |
|---------|------|----------|
| [엣지 케이스명] | [특수 조건] | [기대 결과] |

### 테스트 도구 (프로젝트에 맞게 선택)
- **Backend**: MockMvc / REST Assured / TestRestTemplate
- **Frontend**: Playwright / Cypress

## 구현 단계

### Phase 1: 기반 작업
- [ ] 타입 정의 추가 <!-- FR1 -->
- [ ] 유틸리티 함수 구현 <!-- FR1, FR2 -->

### Phase 2: 핵심 기능
- [ ] 메인 로직 구현 <!-- FR2, FR3 -->
- [ ] API 엔드포인트 (해당시) <!-- FR3 -->

### Phase 3: UI (해당시)
- [ ] 컴포넌트 구현
- [ ] 스타일링

### Phase 4: 테스트
- [ ] 단위 테스트
- [ ] 통합 테스트 (해당시)

## 기술 결정

| 항목 | 결정 | 이유 |
|-----|-----|-----|
| 상태관리 | Zustand | 프로젝트 기존 패턴 |
| 폼 검증 | Zod | 타입 안전성 |

## 아키텍처 준수사항

### 백엔드 (해당시)
- 의존성 방향: domain ← application ← infrastructure
- 유스케이스 분리 원칙
- 포트/어댑터 패턴

### 프론트엔드 (해당시)
- Server Components 우선
- 상태 관리 패턴 (클라이언트: Zustand, 서버: React Query)
- Feature 격리 원칙

## 주의사항
- [구현 시 주의할 점]
- [잠재적 이슈]
- [의존성 고려사항]

## 검증 기준

### FR별 검증
| FR | AC | 검증 방법 | 상태 |
|----|-----|----------|------|
| FR1 | [AC] | [검증 방법] | [ ] |
| FR2 | [AC] | [검증 방법] | [ ] |

### 일반 검증
- [ ] 린트/타입 체크 통과
- [ ] 테스트 통과
- [ ] E2E 테스트 시나리오 통과
- [ ] Breaking Change 규칙 준수 (해당시)
- [ ] 기존 코드와 중복 없음
- [ ] 수정 범위 최소화됨
```

## 섹션별 작성 가이드

### 변경 파일 목록

**파일 순서**: 의존성 순서대로 나열
1. 타입/인터페이스 정의
2. 유틸리티/헬퍼
3. 도메인 로직
4. 애플리케이션 서비스
5. 인프라/어댑터
6. UI 컴포넌트
7. 테스트

### Phase 설계 원칙

1. **의존성 순서**: 의존되는 것부터 구현
2. **테스트 가능 단위**: 각 Phase 완료 후 검증 가능
3. **독립성**: 한 Phase 실패해도 이전 Phase는 유효

### Breaking Change 작성

**V2 필요한 경우:**
- 응답/요청 필드 삭제 또는 이름 변경
- 필드 타입 변경
- DTO 구조 변경
- 에러 코드/메시지 변경

**V2 불필요한 경우:**
- optional 필드 추가
- 내부 로직 변경 (API 계약 유지)

### 마이그레이션 가이드 예시

```markdown
### 마이그레이션 가이드

#### 변경 사항
- `name` 필드가 `firstName`, `lastName`으로 분리

#### Before
```json
{ "name": "John Doe" }
```

#### After
```json
{ "firstName": "John", "lastName": "Doe" }
```

#### 마이그레이션 방법
1. `getUsersV2()` 호출로 변경
2. 응답 처리 로직에서 `firstName`, `lastName` 사용
```
